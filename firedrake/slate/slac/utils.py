import collections

from coffee import base as ast
from coffee.visitor import Visitor

from collections import OrderedDict

from ufl.algorithms.multifunction import MultiFunction


class RemoveRestrictions(MultiFunction):
    """UFL MultiFunction for removing any restrictions on the
    integrals of forms.
    """
    expr = MultiFunction.reuse_if_untouched

    def positive_restricted(self, o):
        return self(o.ufl_operands[0])


class SymbolWithFuncallIndexing(ast.Symbol):
    """A functionally equivalent representation of a `coffee.Symbol`,
    with modified output for rank calls. This is syntactically necessary
    when referring to symbols of Eigen::MatrixBase objects.
    """

    def _genpoints(self):
        """Parenthesize indices during loop assignment"""
        pt = lambda p: "%s" % p
        pt_ofs = lambda p, o: "%s*%s+%s" % (p, o[0], o[1])
        pt_ofs_stride = lambda p, o: "%s+%s" % (p, o)
        result = []

        if not self.offset:
            for p in self.rank:
                result.append(pt(p))
        else:
            for p, ofs in zip(self.rank, self.offset):
                if ofs == (1, 0):
                    result.append(pt(p))
                elif ofs[0] == 1:
                    result.append(pt_ofs_stride(p, ofs[1]))
                else:
                    result.append(pt_ofs(p, ofs))
        result = ', '.join(i for i in result)

        return "(%s)" % result


class Transformer(Visitor):
    """Replaces all out-put tensor references with a specified
    name of :type: `Eigen::Matrix` with appropriate shape. This
    class is primarily for COFFEE acrobatics, jumping through
    nodes and redefining where appropriate.

    The default name of :data:`"A"` is assigned, otherwise a
    specified name may be passed as the :data:`name` keyword
    argument when calling the visitor.
    """

    def visit_object(self, o, *args, **kwargs):
        """Visits an object and returns it.

        e.g. string ---> string
        """
        return o

    def visit_list(self, o, *args, **kwargs):
        """Visits an input of COFFEE objects and returns
        the complete list of said objects.
        """
        newlist = [self.visit(e, *args, **kwargs) for e in o]
        if all(newo is e for newo, e in zip(newlist, o)):
            return o

        return newlist

    visit_Node = Visitor.maybe_reconstruct

    def visit_FunDecl(self, o, *args, **kwargs):
        """Visits a COFFEE FunDecl object and reconstructs
        the FunDecl body and header to generate
        ``Eigen::MatrixBase`` C++ template functions.

        Creates a template function for each subkernel form.

        .. code-block:: c++

            template <typename Derived>
            static inline void foo(Eigen::MatrixBase<Derived> const & A, ...)
            {
              [Body...]
            }
        """
        name = kwargs.get("name", "A")
        new = self.visit_Node(o, *args, **kwargs)
        ops, okwargs = new.operands()
        if all(new is old for new, old in zip(ops, o.operands()[0])):
            return o

        ret, kernel_name, kernel_args, body, pred, headers, template = ops

        body_statements, _ = body.operands()
        decl_init = "const_cast<Eigen::MatrixBase<Derived> &>(%s_);\n" % name
        new_dec = ast.Decl(typ="Eigen::MatrixBase<Derived> &", sym=name,
                           init=decl_init)
        new_body = [new_dec] + body_statements
        eigen_template = "template <typename Derived>"

        new_ops = (ret, kernel_name, kernel_args,
                   new_body, pred, headers, eigen_template)

        return o.reconstruct(*new_ops, **okwargs)

    def visit_Decl(self, o, *args, **kwargs):
        """Visits a declared tensor and changes its type to
        :template: result `Eigen::MatrixBase<Derived>`.

        i.e. double A[n][m] ---> const Eigen::MatrixBase<Derived> &A_
        """
        name = kwargs.get("name", "A")
        if o.sym.symbol != name:
            return o
        newtype = "const Eigen::MatrixBase<Derived> &"

        return o.reconstruct(newtype, ast.Symbol("%s_" % name))

    def visit_Symbol(self, o, *args, **kwargs):
        """Visits a COFFEE symbol and redefines it as a Symbol with
        FunCall indexing.

        i.e. A[j][k] ---> A(j, k)
        """
        name = kwargs.get("name", "A")
        if o.symbol != name:
            return o

        return SymbolWithFuncallIndexing(o.symbol, o.rank, o.offset)


def topological_sort(exprs):
    """Returns a topologically sorted list of Slate expressions.
    The list is generated by examining the dependencies of each
    expression and moving nodes that have all its dependencies
    resolved. A node is resolved once all the nodes in its dependencies
    have been moved into the sorted list.

    A list of expressions, say [D, C, B, A], is provided and a dependency
    graph is generated based on the operands of each expression. If
    the dependency graph looks like

    G = { D: [B, A],
          C: [B],
          B: [],
          A: [] }

    i.e., D depends on A and B, C depends on B, and A and B don't depend
    on any expression, then [A, B, C, D] is returned.

    :arg exprs: An iterable of Slate nodes.
    """
    # Generate the graph as a dictionary whose keys are the Slate nodes.
    # Don't include the expr itself in its dependencies
    dependency_info = [(expr, set(traverse_dags([expr])) - {expr})
                       for expr in exprs]
    dependency_graph = OrderedDict(dependency_info)

    schedule = []
    while dependency_graph:
        for expr in list(dependency_graph.keys()):
            if not dependency_graph[expr].intersection(dependency_graph):
                schedule.append(expr)
                break
        else:
            raise RuntimeError("A cyclic dependency is found.")

        del dependency_graph[expr]

    return schedule


# Thanks, Miklos!
def traverse_dags(expr_dags):
    """Traverses a DAG and returns the unique operands associated
    with the DAG.

    :arg expr_dags: an iterable of Slate nodes that make up the
                    DAG of a given Slate expression.
    """
    seen = set()
    container = []

    for tensor in expr_dags:
        if tensor not in seen:
            seen.add(tensor)
            container.append(tensor)

    while container:
        tensor = container.pop()
        yield tensor
        for operand in tensor.operands:
            if operand not in seen:
                seen.add(operand)
                container.append(operand)


# This function is based on the GEM DAG reference count
# algorithm in TSFC and adapted for Slate tensors.
def collect_reference_count(expr_dags):
    """Returns a mapping from operand to reference count.

    :arg expr_dags: an iterable of Slate nodes that make up the
                    DAG of a given Slate expression.
    """
    result = collections.Counter(expr_dags)
    for tensor in traverse_dags(expr_dags):
        result.update(tensor.operands)

    return result
